#include "include/graph_struct.h"
#include "include/grid_mrf.h"

#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>

#include <iostream>
using namespace std;
using namespace cv;

int main(int argc, char **argv)
{
	if (argc < 3)
	{
		cout << "Parameters too few." << endl;
		return 1;
	}

	Mat left_img = imread(string(argv[1]), CV_LOAD_IMAGE_GRAYSCALE);
	Mat right_img = imread(string(argv[2]), CV_LOAD_IMAGE_GRAYSCALE);

	if (left_img.rows != right_img.rows || left_img.cols != right_img.cols)
	{
		return 2;
	}

	GaussianBlur(left_img, left_img, Size(3,3), 0.7);
	GaussianBlur(left_img, left_img, Size(3,3), 0.7);

	int rows = left_img.rows;
	int cols = left_img.cols;
	int **observed_data = new int*[rows * cols];
	for (int i = 0; i < rows * cols; i++)
	{
		observed_data[i] = new int[LABEL_SET_SIZE];
	}

	for (int y = 0; y < rows; y++)
	{
		for (int x = 0; x < cols; x++)
		{
			int loc = y * cols + x;
			for (int k = 0; k < LABEL_SET_SIZE; k++)
			{
			    int x0 = x, y0 = y;
			    int x1 = max(x0 - k, 0);
			    int diff = 0;
			    for (int i = -1; i <= 1; i++)
			    {
			    	for (int j = -1; j <= 1; j++)
			    	{
			    		diff += abs(left_img.at<unsigned char>(min(max(y0 + i, 0), rows - 1)
			    				                               , min(max(x0 + j, 0), cols - 1))
			    				    - right_img.at<unsigned char>(min(max(y0 + i, 0), rows - 1)
				                               , min(max(x0 + j, 0), cols - 1)));
			    	}
			    }
			    observed_data[loc][k] = abs(left_img.at<unsigned char>(y, x0) - right_img.at<unsigned char>(y, x1));
			}
		}
	}


    grid_mrf mrf(rows, cols, observed_data);
    mrf.draw_graph();

	for (int i = 0; i < rows * cols; i++)
	{
		delete [] observed_data[i];
	}

	delete [] observed_data;

    mrf.inference(BP_MIN_SUM, 10, false);
	return 0;
}
