#include "../include/graph_struct.h"

sparse_graph::sparse_graph(int vn, int is_directed)
: is_directed_(is_directed), nodes_total_count_(vn), edges_total_count_(0)
{
	nodes_.reserve(nodes_total_count_);
	nodes_.resize(nodes_total_count_);

	for (int i = 0; i < nodes_total_count_; i++)
	{
        nodes_[i] = tr1::shared_ptr<graph_node>(new graph_node());
        nodes_[i]->node_id = i;
	}
}

int sparse_graph::insert_edge(int v, int w)
{
	if (v < 0 || v >= nodes_total_count_
		|| w < 0 || w >= nodes_total_count_
		|| v == w)
	{
		return -1;
	}

    tr1::shared_ptr<graph_edge> edge(new graph_edge());
    edge->v = nodes_[v];
    edge->w = nodes_[w];

    nodes_[v]->incident_edges.insert(nodes_[v]->incident_edges.end(), edge);

    if (!is_directed_)
    {
    	tr1::shared_ptr<graph_edge> edge(new graph_edge());
		edge->v = nodes_[w];
		edge->w = nodes_[v];

		nodes_[w]->incident_edges.insert(nodes_[w]->incident_edges.end(), edge);
    }

    edges_total_count_++;

	return 0;
}

int sparse_graph::remove_edge(int v, int w)
{
	if (v < 0 || v >= nodes_total_count_
		|| w < 0 || w >= nodes_total_count_
		|| v == w)
	{
		return -1;
	}

	tr1::shared_ptr<graph_node> v_node = nodes_[v];

	for (list<tr1::shared_ptr<graph_edge> >::iterator it = v_node->incident_edges.begin()
		; it != v_node->incident_edges.end()
		;)
	{
        if ((*it)->w->node_id == w)
        {
        	it = v_node->incident_edges.erase(it);
        }
        else
        {
        	it++;
        }
	}

	if (!is_directed_)
	{
		tr1::shared_ptr<graph_node> v_node = nodes_[w];

		for (list<tr1::shared_ptr<graph_edge> >::iterator it = v_node->incident_edges.begin()
			; it != v_node->incident_edges.end()
			;)
		{
	        if ((*it)->w->node_id == v)
	        {
	        	it = v_node->incident_edges.erase(it);
	        }
	        else
	        {
	        	it++;
	        }
		}
	}

	edges_total_count_--;

	return 0;
}

int sparse_graph::nodes_count(int node_type)
{
	int cnt = 0;
	if (node_type == -1)
	{
		return cnt = nodes_total_count_;
	}

	for (vector<tr1::shared_ptr<graph_node> >::iterator it = nodes_.begin()
		; it != nodes_.end()
		; it++)
	{
		if (node_type != -1 && (*it)->node_type == node_type)
        {
        	cnt++;
        }
	}

	return cnt;
}

int sparse_graph::edges_count()
{
	return edges_total_count_;
}

bool sparse_graph::edge_exists(int v, int w)
{
	bool ret = false;
	if (v < 0 || v >= nodes_total_count_
		|| w < 0 || w >= nodes_total_count_
		|| v == w)
	{
		return ret;
	}


	tr1::shared_ptr<graph_node> v_node = nodes_[v];

	for (list<tr1::shared_ptr<graph_edge> >::iterator it = v_node->incident_edges.begin()
		; it != v_node->incident_edges.end()
		;)
	{
        if ((*it)->w->node_id == w)
        {
        	ret = true;
        	break;
        }
	}

	return ret;
}

int sparse_graph::set_node_type(int node_id, int node_type)
{
	if (node_id < 0 || node_id >= nodes_total_count_)
	{
		return -1;
	}

	nodes_[node_id]->node_type = node_type;

	return 0;
}

sparse_graph::adj_iterator::adj_iterator(const sparse_graph &graph, int v): graph_(graph)
, v_(v), it_(graph_.nodes_[v_]->incident_edges.begin())
{
}

int sparse_graph::adj_iterator::begin()
{
    it_ = graph_.nodes_[v_]->incident_edges.begin();

	if (it_ != graph_.nodes_[v_]->incident_edges.end())
	{
        return (*it_)->w->node_id;
	}

    return -1;
}

int sparse_graph::adj_iterator::next()
{
	it_++;
	if (it_ != graph_.nodes_[v_]->incident_edges.end())
	{
        return (*it_)->w->node_id;
	}

	return -1;
}

bool sparse_graph::adj_iterator::end()
{
	return it_ == graph_.nodes_[v_]->incident_edges.end() ? true : false;
}

