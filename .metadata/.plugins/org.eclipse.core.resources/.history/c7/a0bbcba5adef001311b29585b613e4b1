#ifndef GRAPH_STRUCT_H
#define GRAPH_STRUCT_H

#include <tr1/memory>
#include <list>
#include <vector>

using namespace std;


struct graph_node;

typedef vector<float> message;

//edge type specified for factor graph
struct graph_edge
{
tr1::shared_ptr<graph_node> v;
tr1::shared_ptr<graph_node> w;
tr1::shared_ptr<message> hot_message;
tr1::shared_ptr<message> cool_message;
};

enum
{
	VAR_NODE = 0,
	FACTOR_NODE,
};



//node specified for factor graph
struct graph_node
{
int node_id;
list<tr1::shared_ptr<graph_edge> > incident_edges;
float (*factor_func)(const vector<int> &param);

int node_type; // 0-variable node or 1-factor node
int label_set_size;

graph_node():node_id(-1), factor_func(NULL), node_type(-1), label_set_size(0) {}

};

//template <typename node_type, typename edge_type>
class sparse_graph
{
protected:
	vector<tr1::shared_ptr<graph_node> > nodes_;
	int is_directed_;
	int nodes_total_count_;
	int edges_total_count_;

public:
	sparse_graph(int vn, int is_directed);
    int insert_edge(int v, int w);
    int remove_edge(int v, int w);
    bool edge_exists(int v, int w);
    int nodes_count(int node_type);
    int edges_count();
    int set_node_type(int node_id, int node_type);
    tr1::shared_ptr<graph_edge> edge_of(int v, int w);

    class adj_iterator
    {
    private:
    	const sparse_graph &graph_;
    	int v_;
    	list<tr1::shared_ptr<graph_edge> >::iterator it_;
    public:
    	adj_iterator(const sparse_graph &graph, int v);
    	int begin();
    	int next();
    	bool end();
    };
};

//typedef sparse_graph<graph_node, graph_edge> graph_topology;
typedef sparse_graph graph_topology;

#endif
