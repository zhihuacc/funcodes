\documentclass[a4paper,5pt]{article}
\setlength{\parindent}{2em}
\setlength{\parskip}{1em}
\usepackage{listings}
\lstset{
         basicstyle=\footnotesize\ttfamily, % Standardschrift
         %numbers=left,               % Ort der Zeilennummern
         numberstyle=\tiny,          % Stil der Zeilennummern
         %stepnumber=2,               % Abstand zwischen den Zeilennummern
         numbersep=5pt,              % Abstand der Nummern zum Text
         tabsize=2,                  % Groesse von Tabs
         extendedchars=true,         %
         breaklines=true,            % Zeilen werden Umgebrochen
         keywordstyle=\color{red},
         frame=single,         
 %        keywordstyle=[1]\textbf,    % Stil der Keywords
 %        keywordstyle=[2]\textbf,    %
 %        keywordstyle=[3]\textbf,    %
 %        keywordstyle=[4]\textbf,   \sqrt{\sqrt{}} %
         stringstyle=\color{white}\ttfamily, % Farbe der String
         showspaces=false,           % Leerzeichen anzeigen ?
         showtabs=false,             % Tabs anzeigen ?
         xleftmargin=17pt,
         framexleftmargin=17pt,
         framexrightmargin=5pt,
         framexbottommargin=4pt,
         %backgroundcolor=\color{lightgray},
         showstringspaces=false      % Leerzeichen in Strings anzeigen ?        
 }
\title{Tensor Product Complex Framelets Toolbox}
\author{Xiaosheng Zhuang,    Zhihua CHE}
\date{}
\begin{document}
\maketitle

\tableofcontents

\section{Installation}
This section will introduce how to build TPCTF-2.0 and its dependences from source codes. We also choose to install everything in a user-defined place. For Linux and MacOS, packages will be installed in \lstinline{/home/youraccount/local}, i.e, \lstinline{~/local}.

\subsection{Building Dependencies}
  TPCTF-2.0 needs OpenCV, FFTW and Config4Star(Cpp version) to build on. OpenCV offers convenient and efficient data structure, i.e, \lstinline{Mat} and \lstinline{_Mat} to handle m-D matrix data. FFTW is a widely-used and high-performance FFT implementation. Config4Star is a flexible configuration file parser.
  
  Before starting, we first go to \lstinline{~/local}, and download and extract the source codes of required packages, and assume three source codes directories are generated in current directory, i.e, \lstinline{./opencv-src, ./fftw-src, ./config4cpp-src}. Note that opencv-2.4.5 and opencv-2.4.9 are tested with TPCTF-2.0 and work well, but opencv-3.0 does not. So don't use opencv-3.0 and above.
  
\subsubsection{OpenCV}

\begin{enumerate}

\item[a)] Create a build directory \lstinline{./opencv-build} for opencv. Then enter it.
\item[b)] Issue the command below to compile.

\lstinline{$ cmake CMAKE_INSTALL_PREFIX=/home/youraccount/local ../opencv-src}
\item[c)] If everything goes well, issue the command below to install the opencv to \lstinline{~/local}.

\lstinline{$ make install}
\end{enumerate}

\subsubsection{FFTW}
\begin{enumerate}
\item[a)] Enter \lstinline{./fftw-src}.
\item[b)] Issue the commands below successively.

\lstinline{$ ./configure --prefix=/home/youraccount/local}    \\
\lstinline{$ make}                                            \\
\lstinline{$ make install}
\end{enumerate}

\subsubsection{Config4Star}
This package is not tested on MacOS officially by its author. But We built and ran it on MacOS perfectly. We need change its scripts a bit to make it work on MacOS.

\begin{enumerate}
\item[a)] Go to \lstinline{./config4cpp-src}
\item[b)] This step is to edit \lstinline{Makefile.inc} and needed only on MacOS. Skip to c) if you are not.
First, open file \lstinline{Makefile.inc}, and then add \lstinline{OS=Linux} right before the line \lstinline{LIB_DIR=$(PROJECT_ROOT)/lib}. Finally goto line \lstinline{ifeq ($(OS),Linux)}, change the following line \lstinline{RANLIB = /bin/true} to \lstinline{RANLIB = /usr/bin/true} and \lstinline{CXX = g++} to \lstinline{CXX = clang++}.
\item[c)] Issue the command below to compile

\lstinline{$ make}
\item[d)] Issue the commands below to copy usefull files to the specified directory.

\lstinline{$ cp -rv include/config4cpp /home/youraccount/local/include}        \\
\lstinline{$ cp -rv lib/libconfig4cpp.a /home/youraccount/local/lib}
\end{enumerate}

\subsection{Building TPCTF-2.0}
\begin{enumerate}
\item[a)] Issue the command below. Note that the additional path should point to \lstinline{local/lib} not \lstinline{local}.

\lstinline{$ export LD_LIBRARY_PATH=/home/youraccount/local/lib:$(LD_LIBRARY_PATH)}
\item[b)] Enter \lstinline{./TPCTF-2.0}.
\item[c)] For Linux, issue the command below. \lstinline{LIB_HOME} specifies where the all previous packages are installed.

\lstinline{$ make LIB_HOME=/home/youraccount/local}

For MacOS, issue the command below

\lstinline{$ make LIB_HOME=/home/youraccount/local OS=MacOS}
\item[d)] Issue the command below to install the package. \lstinline{DIR} specifies where the package will be installed.

\lstinline{$make install DIR=/home/youraccount/local}

\end{enumerate}


\section{How to Use Binary Command}

\subsection{Overview}

The command \lstinline{tpctf2} is always issued in this format

\lstinline{$ tpctf2 [sub_commands] [options or parameters]}

Currently the subcommands of \lstinline{denoise, inpaint, cvtxml and psnr} are supported. Here is an example.

\lstinline{$ tpctf2 denoise -cfg denoise.txt}

\lstinline{denoise} is subcommand, and \lstinline{-cfg denoise.txt} is an option to specify that \lstinline{denoise.txt} is the configuration file for this subcommand.

\subsection{Denoise}
This subcommand always requires a configuration file in which all the parameters of controlling the denoising procedure are contained. The option \lstinline{-cfg} specifies the configuration file. This following is an full example config file for \lstinline{denoise}. Lines leading with \lstinline{#} are comments for each parameter.

\begin{lstlisting}
# There must be space before and after ?= .
# You can override values in configuration file by adding command line options like this
# $ ./tpctf2 denoise -set nlevels 2

# This list indicates input image or video files.
fnames = ["Test-Data/Lena512.png"];

# Specify the dec/rec levels
nlevels ?= "5";

# Specify the filter system. Currently support 'CTF3', 'CTF6', 'CTF6D4', 'CTF4'.
fs ?= "CTF6D4";

# Specify how many pixels will be expanded by.
# Note: The program will figure a better number based on this parameter. The better one may be different from the parameter. Normally (not necessarily) it will be 2^(nlevels + 1)
ext_size ?= "64";

# Specify how the expanded pixels are interpolated. Currently support 'rep', 'mir1001', 'mir101', 'blk'.
ext_method ?= "mir1001";

# Indicate whether the program speeds up by taking advtange of symmetry.
is_sym ?= "true";

doSave ?= "true";

# Specify the mean of estimated noises.
mean ?= "0";

# Specify the standard deviation of estimated noises.
stdev ?= "5";

# Specify the const coefficient used in thresholding.
c ?= "1.732051";

# Specify the filter window width to do smooth convolution.
wwidth ?= "7";

# Indicate whether to do coefficient normalization.
doNorm ?= "true";

# Specify which method is used to do thresholding. Currently support 'localsoft', 'localadapt', 'bishrink'.
thr_method ?= "bishrink";
\end{lstlisting}

  When issuing this command, the value in the configuration file can be override by option $-set$. The format is \textit{-set parameter\_name  new\_parameter\_value}
  
  \$ ./tpctf2 denoise -cfg denoise.txt -set nlevels 2
  
  Then the value of $nlevels$ would be 2 instead of 5 as specified in the file.
  
\subsection{Inpaint}

  This command also requires a configuration file as \lstinline{denoise}. The following is full example configuration file.
  
\begin{lstlisting}

# 'fnames' is a list of names of files to be inpainted. 
# These files may contain gaussian noises and masked areas.
# 'masks' is a list of names of files which act as masks.
fnames ?= ["Test-Data/Lena512.png"];
masks ?= ["Test-Data/Text3.png"];

# Indicate the end of first and second phase of sigmas array.
# Clearly phase2_end is also equal to the total number of sigmas.
phase1_end ?= "5";
phase2_end ?= "13";

# Specify the err tolerance of two phases.
epsilon1 ?= "5e-3";
epsilon2 ?= "1e-4";

# Currently support 'auto', 'manul'.
# If 'auto', it will compute sigmas array according to formula in the paper.
# If 'manul', it will use sigmas specified in the following parameter 'sigmas'.
sigma_method ?= "auto";

# This is the sigma array the inpaint procedure will iterate on if 'manul' is specified above.
# This array consists of two phases.
# The first phase stops at phase1_end.
sigmas ?= ["512.0000", "227.6198", "101.1929", "44.9873", "20.0000",  "15.0000", "10.1877", "6.9193", "4.6995", "3.1918", "2.1678", "1.4724", "1.0000"];

# Specify the denoising parameters which will be used in each 'denoising' step.
# The value should match a subscope name defined below. 
# Those subscopes define the denoising parameters in detail.
params ?= ["CTF3a", "CTF3a", "CTF3a", "CTF3a", 
           "CTF3a", "CTF6a", "CTF6a", "CTF6a", "CTF6a", 
           "CTF6a", "CTF6a", "CTF6a", "CTF6a"];

# Specify the maximum iter number. The procedure will
# iterate no more than this number.
max_iter ?= "1000";

# Indicate how many pixels will be expanded by.
# Note: This is different from command 'denoise', 
#       where the program would figure a better size,
#       while inpaint will not.
# This means the program will expand the matrix exactly by this size. 
# So please choose a good number here.
ext_size ?= "8";
ext_method ?= "mir1001";


# Specify the sigma of noises added in original data.
noise_sigma ?= "5";


# Subscopes where denoising parameters are defined.
# Different subscopes define different denoising parameters.
# The meaning of these parameters can be found in the section 2.2
CTF3a {
nlevels ?= "2";
fs ?= "CTF3";
is_sym ?= "true";

c ?= "1.73205";
wwidth ?= "7";
doNorm ?= "true";
thr_method ?= "bishrink";
}

CTF6a {
nlevels ?= "2";
fs ?= "CTF6";
is_sym ?= "true";

c ?= "1.73205";
wwidth ?= "7";
doNorm ?= "true";
thr_method ?= "bishrink";
}

\end{lstlisting}

As \lstinline{denoise}, option \lstinline{-set} can  override the value in configuration file.

\subsection{Convert to XML}

\lstinline{cvtxml} can convert files in image, video format into xml format. Issue command like this

\lstinline{$ ./tpctf2 cvtxml Lena512.png Lena512.xml}

The command converts \lstinline{Lena512.png} into \lstinline{Lena512.xml}, keeping the same data.

\section{How to Link this Library}
We will show how to link user code with this library in Linux. The following is a simple code loading two matrices and compute the psnr between them. The file is \lstinline{psnr.cpp}. We assume familarity with C++ template technique.

\begin{lstlisting}
#include <iostream>
#include <string>
#include "tpctf/mat_toolbox.h"

using namespace std;

int main(int argc, char **argv)
{
typedef double FLOAT_TYPE;
	Mat_<Vec<FLOAT_TYPE, 2> > left_mat, right_mat;
	Media_Format mfmt1, mfmt2;
	load_as_tensor<FLOAT_TYPE>(string(argv[1]), left_mat, &mfmt1);
	load_as_tensor<FLOAT_TYPE>(string(argv[2]), right_mat, &mfmt2);

	double score, msr;
	psnr<FLOAT_TYPE>(left_mat, right_mat, score, msr);

	cout << "PSNR: " << score << ", MSR: " << msr << endl;
}
\end{lstlisting}

Compile the code by issuing the following command

\lstinline{$g++ -o psnr psnr.cpp -L/home/youraccount/local/lib -lopencv_core -lopencv_imgproc -lopencv_highgui -lconfig4cpp -lfftw3 -ltpctf -std=c++0x -I/home/youraccount/local/include -O3 -Wall}

If everything goes OK, an executable \lstinline{psnr} is produced. We can compute psnr of two images like this

\lstinline{$ ./psnr Lena512.png Lena512-denoised.png}

\section{API reference}

\subsection{Overview}
This section gives a detailed description on public api in this package. The package consists of several submodules.

\lstinline{mat_toolbox.h} contains low-level interfaces which do basic operations on data matrix, e.g, loading/saving, arithmetic operations like add and multiplication, border extension, rotation etc.

\lstinline{wavelets_toolbox.h} contains interfaces to do decomposition and reconstruction using tensor product complex framelets technique.

\lstinline{denoise.h} and \lstinline{inpaint.h} contains interfaces doing denoising and inpainting by processing coefficients produced from interfaces above.

The packages are implemented using C++ template technique.

\subsection{load\_as\_tensor/save\_as\_media}
\lstinline{template<typename _Tp> int load_as_tensor(const string &filename, Mat_<Vec<_Tp, 2> > &mat, Media_Format *mfmt)}


This interface loads data matrix from images, videos, xml files.

\begin{itemize}
\item \lstinline{filename} Name of the file to load from.
\item \lstinline{mat} Output data matrix returned.
\item \lstinline{mfmt} An output contaning various properties about the file. It can be \lstinline{NULL} if not needed.
\end{itemize}

\noindent
\lstinline{template<typename _Tp> int save_as_media(const string &filename, const Mat_<Vec<_Tp, 2> > &mat, const Media_Format *mfmt) }

This interface saves data matrix into images, videos, xml files.

\begin{itemize}
\item \lstinline{filename} Name of the file to save to.
\item \lstinline{mat} Input data matrix to save.
\item \lstinline{mfmt} An input contaning various properties about the file. It can be \lstinline{NULL} if not needed.
\end{itemize}

\subsection{decompose\_by\_ml\_md\_filter\_bank}

\lstinline {int decompose_by_ml_md_filter_bank(const ML_MD_FS_Param &fs_param, const Mat_<Vec<_Tp, 2> > &input, ML_MD_FSystem<_Tp> &filter_system, typename ML_MC_Filter_Norms_Set<_Tp>::type &norms_set, typename ML_MC_Coefs_Set<_Tp>::type &coefs_set) }

This interface decomposes a matrix into coefficients.
\begin{itemize}
\item \lstinline{fs_param} this is a structure containing parameters of controlling decomposition and reconstruction procedure.
\item \lstinline{input} input matrix to be decomposed.
\item \lstinline{filter_system}  This is an output argument. It contains the resulting 1-d filters used to construct m-D filters. They are constructed during doing decomposition, according the parameters in \lstinline{fs_param}. These filters will be passed into reconstruction interface to re-use, so that it can save the time to construct them again.
\item \lstinline{norms_set} It is an output argument. It contains the norms of the M-d filters. They are used in various procedures later, like denoising. It is actually 2-d double-type array. \lstinline{norms_set[i][j]} is the ith-level, jth-channel filter's norm. The last element of last level is the low-pass filter's norm.
\item \lstinline{coefs_set} It is an output argument. It contains time-domain coefficients of input produced by this procedure. It has a similar structure as \lstinline{norms\_set}. \lstinline{norms_set[i][j]} is the ith-level, jth-channel coeficient. The last element of last level is the low-pass filter's coeficient.
\end{itemize}

  
  The detailed definition of \lstinline{ML_MD_FS_Param} is following.
\begin{lstlisting}


// ML_MD_FS_Param is a hierachical structure and there exists one element for each dimension and each level.
struct ML_MD_FS_Param
{
	// md_fs_param_at_level is an array of parameter structure. Each element of type MD_FS_Param corresponds to one level, which specfies m-d filter systems in this level.
	SmartArray<MD_FS_Param> md_fs_param_at_level;
	
	// Specfiy how many levels the filter systems is of.
	int 					nlevels;
	
	// Specfiy how many dimensions the filter systems is of at each level.
	int 					ndims;
	
	// Specify how many pixels will be expanded
	SmartIntArray			ext_border;
	
	// Specify how the expaneded pixels are interpolated.
	string					ext_method;
	// Indicate if symmetry speedup is used
	bool 					isSym;
	
	...
};
\end{lstlisting}

You may note that the parameters in the structure corresponds to those in configuration file. That is right. Commands \lstinline{denoise} and \lstinline{inpaint} read values in configuration file and pass them into appropriate interfaces. The code snippet below loads an image and decomposes it into coefficient.

\begin{lstlisting}
	typedef double FLOAT_TYPE;

	Mat_<Vec<FLOAT_TYPE, 2> > noisy_mat;
	Media_Format mfmt;
	load_as_tensor<FLOAT_TYPE>("img.png", noisy_mat, &mfmt);
	
	int ndims = noisy_mat.dims;
	int nlevels = 5;
	string fs_opt("CTF3");
	int ext_size = 64;
	string ext_method("bishrink");
	bool is_sym = true;

	ML_MD_FS_Param fs_param;
	int ret = compose_fs_param(nlevels, ndims, fs_opt, ext_size, ext_method, is_sym, fs_param);
	if (ret)
	{
		cout << "Error in FS param. " << endl;
		return 0;
	}
	
	ML_MD_FSystem<FLOAT_TYPE> 					        filter_system;
	typename ML_MC_Coefs_Set<FLOAT_TYPE>::type 		    coefs_set, new_coefs_set;
	typename ML_MC_Filter_Norms_Set<FLOAT_TYPE>::type 	norms_set;
	decompose_by_ml_md_filter_bank<FLOAT_TYPE>(noisy_mat, fs_param, filter_system, norms_set, coefs_set);
	
	// Now we can process the coefficients and save new coefficients in new_coef_set.
	
\end{lstlisting}
  \lstinline{load_as_tensor} loads data in image, video, xml file and returns a Mat object. All other interfaces will take \lstinline{Mat_} as input or output.
  \lstinline{compose_fs_param} create a \lstinline{ML_MD_FS_Param} object by composing and checking various parameters.
  \lstinline{decompose_by_ml_md_filter_bank} takes \lstinline{noisy_mat} as input data to decompose, \lstinline{fs_param} as parameters to control the decomposition; meanwhile, \lstinline{ filter_system} as output containing 1-d filters used to construct m-D filters, \lstinline{norms_set} containing norms of the m-d filters, \lstinline{coefs_set} containing resulting coeficients. 


\subsection{reconstruct\_by\_ml\_md\_filter\_bank}

\lstinline{ template<typename _Tp> int reconstruct_by_ml_md_filter_bank(const ML_MD_FS_Param &fs_param, const ML_MD_FSystem<_Tp> &filter_system, const typename ML_MC_Coefs_Set<_Tp>::type &coefs_set, Mat_<Vec<_Tp, 2> > &rec) }

This interface reconstruct a matrix from a set of coefficients.
\begin{itemize}
\item \lstinline{fs_param} Same as in \lstinline{decompose_by_ml_md_filter_bank}
\item \lstinline{filter_system} It is input and the same as output of \lstinline{decompose_by_ml_md_filter_bank}. 

\item \lstinline{coefs_set} It contains coefficients by which this interface will reconstruct matrix.
\item \lstinline{rec} The reconstructed matrix as output. 
\end{itemize}

The code snippet below follows the one above.

\begin{lstlisting}
  \\ After coefficients are processed and new_coefs_set is ready.
  Mat_<Vec<FLOAT_TYPE, 2> > rec;
	reconstruct_by_ml_md_filter_bank<FLOAT_TYPE>(ml_md_fs_param, filter_system, new_coefs_set, rec);
	
\end{lstlisting}

\subsection{thresholding}

\lstinline{ template<typename _Tp> int thresholding(const typename ML_MC_Coefs_Set<_Tp>::type &coefs_set, const string &opt, int wwidth, double c, double sigma, typename ML_MC_Coefs_Set<_Tp>::type &thr_set) }

This interface does thresholding on coefficients.
\begin{itemize}
\item \lstinline{coefs_set} Input coefficients to do thresholding on.
\item \lstinline{opt} Indicates which method is used to do thresholding, currently support \lstinline{localsoft}, \lstinline{localadapt}, \lstinline{bishrink}.
\item \lstinline{wwidth} Widow width to do convolution with.
\item \lstinline{c} Constant value to control thresholding.
\item \lstinline{sigma} Estimated noise sigma in original matrix.
\item \lstinline{thr_set} New coefficients as output.
\end{itemize}

\subsection{normalize\_coefs}

\lstinline{template <typename _Tp> int normalize_coefs(const typename ML_MC_Coefs_Set<_Tp>::type &coefs_set, const typename ML_MC_Filter_Norms_Set<_Tp>::type &norms_set, bool forward, typename ML_MC_Coefs_Set<_Tp>::type &ncoefs_set) }

This interface normalizes/inverse-normalizes the coefficients.

\begin{itemize}
\item \lstinline{coefs_set} Input coefficients to be normalized\/inverse-normalized.
\item \lstinline{norms_set} Input containing norms of m-D filters produced from \lstinline{decompose_by_ml_md_filter_bank}.
\item \lstinline{forward} Indicates this is to normalize or inverse-normalize.
\item \lstinline{ncoefs_set} Output containing new coefficients.
\end{itemize}

The following code is how to do thresholding on coefficients.

\begin{lstlisting}
  // After calling decompose_by_ml_md_bank

	normalize_coefs<FLOAT_TYPE>(coefs_set, norms_set, true, coefs_set);
	
	thresholding<FLOAT_TYPE>(coefs_set, "localsoft", 7, 1.732, 5, new_coefs_set);

	normalize_coefs<FLOAT_TYPE>(new_coefs_set, norms_set, false, new_coefs_set);
	
  // Before calling reconstruct_by_ml_md_bank
\end{lstlisting} 

  This snippet normalizes the coefficients first, then does thresholding, and finally inverse-normalizes the new coefficients.
  
\subsection{normalized\_fft/normalized\_ifft}

\lstinline{template<typename _Tp> int normalized_fft(const Mat_<Vec<_Tp, 2> > &time_domain, Mat_<Vec<_Tp, 2> > &freq_domain) }

This interface does FFT forward.

\begin{itemize}
\item \lstinline{time_domain} Input data matrix storing signal in time domain.
\item \lstinline{freq_domain} Output data matrix storing fequencies in frequency domain.
\end{itemize}

\noindent
\lstinline{template<typename _Tp> int normalized_ifft(const Mat_<Vec<_Tp, 2> > &freq_domain, Mat_<Vec<_Tp, 2> > &time_domain) }

This interfaces does FFT inverse.

\begin{itemize}
\item \lstinline{freq_domain} Input data matrix storing fequencies in frequency domain.
\item \lstinline{time_domain} Output data matrix storing signal in time domain.
\end{itemize}

The following snipet shows the usage. Note that after doing FFT and IFFT using the two interfaces successively, exactly same time-domain signal would be recovered without being scaled, i.e., the result is normalized.

\begin{lstlisting}
 ...
 normalized_fft<FLOAT_TYPE>(time_domain, freq_domain);
 ...
 
 // The data in time_domain is the same as before.
 normalized_ifft<FLOAT_TYPE>(freq_domain, time_domain);
 ...

\end{lstlisting}


\end{document}